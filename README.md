# Simulation-of-a-P2P-Cryptocurrency-Network
# CS765 Project

--Harsh Raj


- InitialUserConfig.txt
	- Peers: `n` (range is `0` to `n-1`) (__TUNE__)
		- Coins Owned by each peer
	- SlowNodePercent: `z`, (100-z) percent will be fast (__TUNE__)
	- CpuPowerRandVariable: `CPU_k` (`0 <= k < n`)
	- Mean Time of Exponential distribution: `T_tx` (__TUNE__)
		- Interarrival between transactions generated by ANY peer
		- Create first transaction for each peer based on exponential distribution (point 2)
	- Connect the peers and make sure the network is connected (point 4)
	- GraphMatrix (Adjacency Matrix) of `n*n` with value = partial info useful to calculate latency at runtime (point 5)
		- `L_ij = ρ_ij + |m|/c_ij + d_ij`
			- `ρij` can be chosen from a uniform distribution between 10ms and 500ms at the start of the simulation.
				- a positive minimum value corresponding to speed of light propagation delay
			- `|m|` denotes the length of the message in bits
			- `cij` is the link speed in bits per second
				- 100 Mbps if both i and j are fast
				- 5 Mbps if either of the nodes is slow
			- `dij` is _random for each message_ - queuing delay at senders side (i.e. node i) (__TUNE__)
				- `dij` is randomly chosen from an exponential distribution with some mean `96kbits/ci,j`
	- Probability of invalid transaction generation
	- GenesisBlock

- Peers Info
	- PeerId
	- SlowFast
	- Maintain a tree of blocks as in bitcoin
	- @method On Receive Block 
		- validate all transactions
		- add to tree of blocks
		- Broadcast the block to others adjacent peers who did not send the same block to current one (take care NOT to create a cycle)
		- Update the current nodes `last receive time`
		- Start PoW mining
			- Select a subset of transaction from the transaction pool (it only contains validated transactions)
			- Set Pow Complete Time = (currentTime + `T_k`) based on exponential distribution (inversely propotional to `CPU_k`)
				- Mining start time
				- (__TUNE__) `T_k` - this is mining time
	- @Mean Receive Transaction
		- todo
	- @method Broadcast Block
		- todo
	- @method Broadcast Transaction
		- Check if transaction is of type "Mining fee"
			- fee should be 50 coins only
			- the block with the hash should be present in the blockchain
		- If transaction is of type "Transfer Money"
			- Check balance
		- Add to Transaction Pool
	- @method PoW Complete
		- Check if `Mining start time < last receive time`; then discard the work don
			- Each node will have its own `last receive time`
		- else
			- create _coinbase transaction_ of 50 coins to itself as mining fee
				- `TxnID:IDk mines 50 coins`
				- Include this in the mined block only
				- 1 KB
			- Broadcast the block

- EventQueue
	- Min Queue
	- Event Structure: Time, EventType, FromWhichNode, ForWhichNode
	- Next Event time = currentTime + latency (point 5)

- Block
	- Max size of __1 MB__ (8 × 1'000'000 bits)
	- Actual size can vary
	- BlkID - unique ID for each block (use SHA256/any other hash)
		- Can choose any method to ensure this
	- Index starting from 0
	- Made of some `X` number of transactions
		- Transaction
			- Size of each transaction is assumed to be 1 KB
			- Format
				- Transaction ID : TxnID
				- Senders ID     : IDx
				- Receivers ID   : IDy
				- Coins          : C
			- Verification/Validation
				- C <= Coins owned by IDx

1 7
2 2
3 4


time t
[2,4,7,10]
 ^




- Each Node
	- ```
          +--d [f]
      a b c 
          +--e l p [z]
          |
          +--q w [r]
               +--[y]
      ```
	- list block_hash of tails [f, z, r, y]
		- inverted priority queue
	- dictionary {block_hash: block_object, receive time}


